import { hitTest, toNumber } from "./utils.js";
import { themeRgba } from "./theme.js";

export function createScene({ config, strings, contexts, elements, themeState, fitBgText }) {
  const { canvas, ctx, sentinelsCanvas, sentinelsCtx, rabbitCanvas, rabbitCtx } = contexts;
  if (!canvas || !ctx || !sentinelsCanvas || !sentinelsCtx || !rabbitCanvas || !rabbitCtx) {
    console.error("Canvas contexts are unavailable; aborting animation setup.");
    return null;
  }

  const chars = config.matrix.chars;
  let width;
  let height;
  let columns;
  let drops;
  const trail = [];
  const bursts = [];
  // Active sentinel entities (spawned and animated each frame).
  const sentinels = [];
  // Rabbit sprite that hops across the screen and acts as a link target.
  const rabbit = {
    x: -40,
    y: window.innerHeight - config.rabbit.yOffset,
    vx: config.rabbit.speed,
    phase: 0,
    scale: config.rabbit.scale
  };
  let lastSpawn = 0;
  let kills = 0;
  let escaped = 0;
  let shakeTimer = 0;
  let glitchTimer = 0;
  const mouse = { x: 0, y: 0, active: false };

  // Flash/glitch feedback when a sentinel escapes off-screen.
  function triggerEscapeEffect() {
    if (!config.features.glitch) return;
    document.body.classList.add("shake", "glitch");
    clearTimeout(shakeTimer);
    clearTimeout(glitchTimer);
    shakeTimer = setTimeout(() => document.body.classList.remove("shake"), 420);
    glitchTimer = setTimeout(() => document.body.classList.remove("glitch"), 520);
  }

  // Cursor trail letters that fade out over time.
  function drawTrail() {
    for (let i = trail.length - 1; i >= 0; i--) {
      const p = trail[i];
      p.life -= 0.03;
      if (p.life <= 0) {
        trail.splice(i, 1);
        continue;
      }
      ctx.fillStyle = themeRgba(themeState, p.life);
      ctx.font = config.trail.fontSize + "px monospace";
      ctx.fillText(p.char, p.x, p.y);
    }
  }

  // Burst particles emitted on click.
  function drawBursts() {
    for (let i = bursts.length - 1; i >= 0; i--) {
      const p = bursts[i];
      p.life -= 0.02;
      if (p.life <= 0) {
        bursts.splice(i, 1);
        continue;
      }
      p.vy += 0.06;
      p.x += p.vx;
      p.y += p.vy;
      ctx.fillStyle = themeRgba(themeState, p.life);
      ctx.font = config.bursts.fontSize + "px monospace";
      ctx.fillText(p.char, p.x, p.y);
    }
  }

  // Spawn and render sentinel enemies, with HP bars on tougher ones.
  function drawSentinels(now) {
    sentinelsCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    const maxSentinels = config.sentinels.max;
    if (now - lastSpawn > config.sentinels.spawnIntervalMs && sentinels.length < maxSentinels) {
      lastSpawn = now;
      const dir = Math.random() > 0.5 ? 1 : -1;
      const scale =
        config.sentinels.scaleRange.min + Math.random() * config.sentinels.scaleRange.extra;
      const speedRoll = Math.random();
      const speedThresholds = config.sentinels.speedThresholds;
      const speedRanges = config.sentinels.speedRanges;
      const baseSpeed =
        speedRoll < speedThresholds.fast
          ? speedRanges.fast.min + Math.random() * speedRanges.fast.extra
          : speedRoll < speedThresholds.mid
            ? speedRanges.mid.min + Math.random() * speedRanges.mid.extra
            : speedRanges.slow.min + Math.random() * speedRanges.slow.extra;
      const hp = speedRoll < speedThresholds.mid ? 1 : config.sentinels.toughHp;
      sentinels.push({
        x: dir > 0 ? -40 : window.innerWidth + 40,
        y: Math.random() * window.innerHeight * 0.9 + 20,
        vx: dir * baseSpeed,
        vy: (Math.random() - 0.5) * 0.2,
        wobble: Math.random() * Math.PI * 2,
        scale,
        life: 1,
        w: 8 * scale,
        h: 8 * scale,
        hp,
        maxHp: hp
      });
    }

    for (let i = sentinels.length - 1; i >= 0; i--) {
      const s = sentinels[i];
      s.wobble += 0.02;
      s.y += s.vy + Math.sin(s.wobble) * config.sentinels.wobbleAmplitude;
      s.x += s.vx;
      if (s.x < -80 || s.x > window.innerWidth + 80) {
        sentinels.splice(i, 1);
        escaped++;
        triggerEscapeEffect();
        continue;
      }
      const px = s.x;
      const py = s.y;
      const unit = s.scale;

      // Pixelated "sentinel" silhouette.
      const pattern = [
        "00111100",
        "01111110",
        "11100111",
        "11011011",
        "11111111",
        "01111110",
        "00111100",
        "00011000"
      ];
      sentinelsCtx.fillStyle = themeRgba(themeState, 0.18);
      sentinelsCtx.shadowColor = themeRgba(themeState, 0.5);
      sentinelsCtx.shadowBlur = 10;
      for (let y = 0; y < pattern.length; y++) {
        for (let x = 0; x < pattern[y].length; x++) {
          if (pattern[y][x] === "1") {
            sentinelsCtx.fillRect(px + x * unit, py + y * unit, unit, unit);
          }
        }
      }
      // Tentacles trailing behind the sentinel.
      sentinelsCtx.shadowBlur = 6;
      sentinelsCtx.strokeStyle = themeRgba(themeState, 0.22);
      sentinelsCtx.lineWidth = Math.max(1, unit / 2);
      const tailDir = s.vx > 0 ? -1 : 1;
      for (let t = 0; t < 5; t++) {
        const startX = px + (pattern[0].length * unit) / 2 + t * unit * 0.6;
        const startY = py + pattern.length * unit - unit;
        sentinelsCtx.beginPath();
        sentinelsCtx.moveTo(startX, startY);
        let cx = startX;
        let cy = startY;
        for (let seg = 0; seg < 6; seg++) {
          cx += tailDir * (2 + seg) * unit * 0.7;
          cy += Math.sin(s.wobble + seg * 0.7 + t) * unit + unit * 0.6;
          sentinelsCtx.lineTo(cx, cy);
        }
        sentinelsCtx.stroke();
      }
      if (s.maxHp > 1) {
        const barW = s.w;
        const barH = Math.max(2, unit / 2);
        const barX = px;
        const barY = py - barH - 3;
        sentinelsCtx.fillStyle = "rgba(0, 0, 0, 0.5)";
        sentinelsCtx.fillRect(barX, barY, barW, barH);
        sentinelsCtx.fillStyle = themeRgba(themeState, 0.7);
        sentinelsCtx.fillRect(barX, barY, barW * (s.hp / s.maxHp), barH);
      }
      sentinelsCtx.shadowBlur = 0;
    }
  }

  // Animate and draw the rabbit sprite, plus update its hitbox.
  function drawRabbit() {
    rabbitCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    rabbit.phase += config.rabbit.phaseStep;
    rabbit.x += rabbit.vx;
    if (rabbit.x > window.innerWidth + config.rabbit.wrapRight) {
      rabbit.x = config.rabbit.wrapLeft;
    }
    const hop = Math.abs(Math.sin(rabbit.phase)) * config.rabbit.hopAmplitude;
    const px = rabbit.x;
    const py = rabbit.y - hop;
    const unit = rabbit.scale;
    const pattern = [
      "00100100",
      "00100100",
      "00111100",
      "01111110",
      "11111111",
      "11111111",
      "11111111",
      "11111111",
      "01111110",
      "01111110",
      "00100100"
    ];
    rabbitCtx.fillStyle = "rgba(230, 255, 255, 0.9)";
    for (let y = 0; y < pattern.length; y++) {
      for (let x = 0; x < pattern[y].length; x++) {
        if (pattern[y][x] === "1") {
          rabbitCtx.fillRect(px + x * unit, py + y * unit, unit, unit);
        }
      }
    }
    // Eyes and tail.
    rabbitCtx.fillStyle = "rgba(20, 25, 20, 0.9)";
    rabbitCtx.fillRect(px + unit * 3, py + unit * 4, unit, unit);
    rabbitCtx.fillRect(px + unit * 5, py + unit * 4, unit, unit);
    rabbitCtx.fillStyle = "rgba(230, 255, 255, 0.9)";
    rabbitCtx.fillRect(px + unit * 7, py + unit * 7, unit, unit);

    rabbit.hit = {
      x: px,
      y: py,
      w: pattern[0].length * unit,
      h: pattern.length * unit
    };
  }

  // Sync all canvases with the viewport size and device pixel ratio.
  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    width = canvas.width = window.innerWidth * dpr;
    height = canvas.height = window.innerHeight * dpr;
    sentinelsCanvas.width = window.innerWidth * dpr;
    sentinelsCanvas.height = window.innerHeight * dpr;
    rabbitCanvas.width = window.innerWidth * dpr;
    rabbitCanvas.height = window.innerHeight * dpr;
    ctx.scale(dpr, dpr);
    sentinelsCtx.scale(dpr, dpr);
    rabbitCtx.scale(dpr, dpr);
    columns = Math.floor(window.innerWidth / config.matrix.columnWidth);
    drops = Array.from({ length: columns }, () => Math.random() * window.innerHeight);
    rabbit.y = window.innerHeight - config.rabbit.yOffset;
    fitBgText();
  }

  // Main animation loop: matrix rain, sentinels, rabbit, and effects.
  function draw() {
    const now = performance.now();
    ctx.fillStyle = "rgba(5, 10, 8, " + config.matrix.fadeAlpha + ")";
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    if (config.features.matrix) {
      ctx.fillStyle = config.palette.green;
      ctx.font = config.matrix.fontSize + "px monospace";
      for (let i = 0; i < drops.length; i++) {
        const char = chars[Math.floor(Math.random() * chars.length)];
        const x = i * config.matrix.columnWidth;
        const y = drops[i] * config.matrix.columnWidth;
        ctx.fillText(char, x, y);
        if (y > window.innerHeight && Math.random() < config.matrix.resetChance) {
          drops[i] = 0;
        }
        drops[i]++;
      }
    }
    if (config.features.sentinels) {
      drawSentinels(now);
    }
    if (config.features.rabbit) {
      drawRabbit();
    }
    if (config.features.trail) {
      drawTrail();
    }
    if (config.features.bursts) {
      drawBursts();
    }
    if (config.features.stats) {
      ctx.fillStyle = config.stats.color;
      ctx.font = config.stats.fontSize + "px monospace";
      ctx.fillText(strings.statsKilledLabel + ": " + kills, 16, window.innerHeight - 16);
      ctx.fillText(strings.statsEscapedLabel + ": " + escaped, 16, window.innerHeight - 32);
    }
    requestAnimationFrame(draw);
  }

  function bindEvents() {
    // Track pointer movement to leave a character trail.
    window.addEventListener("pointermove", (event) => {
      if (!config.interactions.enabled || !config.features.trail) return;
      mouse.active = true;
      mouse.x = toNumber(event.clientX, 0);
      mouse.y = toNumber(event.clientY, 0);
      trail.push({
        x: mouse.x,
        y: mouse.y,
        life: 0.9,
        char: chars[Math.floor(Math.random() * chars.length)]
      });
      if (trail.length > config.trail.max) {
        trail.splice(0, trail.length - config.trail.max);
      }
    });

    // Click handler for rabbit link and sentinel hits.
    window.addEventListener("pointerdown", (event) => {
      if (!config.interactions.enabled) return;
      const clickX = toNumber(event.clientX, 0);
      const clickY = toNumber(event.clientY, 0);
      if (config.features.rabbit && rabbit.hit && hitTest(clickX, clickY, rabbit.hit)) {
        window.location.href = config.rabbitUrl;
        return;
      }
      // Click to destroy sentinels.
      if (config.features.sentinels) {
        for (let i = sentinels.length - 1; i >= 0; i--) {
          const s = sentinels[i];
          if (hitTest(clickX, clickY, s)) {
            s.hp -= 1;
            if (s.hp <= 0) {
              sentinels.splice(i, 1);
              kills++;
            }
            break;
          }
        }
      }
      if (config.features.bursts) {
        const count = config.bursts.count;
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 1 + Math.random() * 2.2;
          bursts.push({
            x: clickX,
            y: clickY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 1.2,
            life: 0.9,
            char: chars[Math.floor(Math.random() * chars.length)]
          });
        }
        if (bursts.length > config.bursts.max) {
          bursts.splice(0, bursts.length - config.bursts.max);
        }
      }
    });

    // Reset transforms then recompute sizes on resize.
    window.addEventListener("resize", () => {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      sentinelsCtx.setTransform(1, 0, 0, 1, 0, 0);
      rabbitCtx.setTransform(1, 0, 0, 1, 0, 0);
      resize();
    });

    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", fitBgText);
      window.visualViewport.addEventListener("scroll", fitBgText);
    }
  }

  function start() {
    try {
      resize();
      bindEvents();
      draw();
    } catch (err) {
      console.error("Animation loop failed to start.", err);
    }
  }

  function clearTrail() {
    trail.length = 0;
  }

  function clearBursts() {
    bursts.length = 0;
  }

  function clearSentinels() {
    sentinels.length = 0;
    sentinelsCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
  }

  return {
    start,
    resize,
    clearTrail,
    clearBursts,
    clearSentinels
  };
}
